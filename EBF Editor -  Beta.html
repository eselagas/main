<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="https://flow.operacdn.com/ext/v1/img/favicon_64_4b10e4fdb7.webp">
  <title>EBF Editor</title>
</head>
<style>
body {
    font-family: 'Roboto', sans-serif;
    margin: 0;
    padding: 0;
    background-color: #f0f0f5;
    align-items: center;
}

@keyframes slide-up {
    from { bottom: -40px; }
    to { bottom: 20px; }
}

.toolbar {
    will-change: bottom;
    display: flex;
    gap: 10px;
    padding: 10px;
    background: rgba(248, 248, 248, 0.621);
    position: fixed;
    width: 90%;
    bottom: 20px;
    left: 5%;
    border-radius: 12px;
    z-index: 10;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    justify-content: center;
    animation: slide-up 1s forwards;
}

.toolbar button, .toolbar select {
    padding: 8px 12px;
    cursor: pointer;
    border: none;
    border-radius: 50px;
    background-color: #6200ea;
    color: #fff;
    font-weight: bold;
    transition: background-color 0.3s ease, transform 0.3s ease;
}

.toolbar button:hover, .toolbar select:hover {
    background-color: #3700b3;
    transform: translateY(-2px);
}

@keyframes fadeOutBoxShadow {
    to {
        box-shadow: none;
    }
}

.toolbar button:focus, .toolbar select:focus {
    outline: none;
    box-shadow: 0 0 5px 2px rgba(172, 113, 255, 0.75);
}

.toolbar button:focus:not(:hover), .toolbar select:focus:not(:hover) {
    animation: fadeOutBoxShadow 2s forwards; /*fade out the box shadow*/
}


#editor {
    position: fixed;
    width: calc(100% - 60px);
    height: calc(100vh - 150px);
    top: 2.5px;
    border: none;
    padding: 20px;
    margin: 10px;
    outline: none;
    overflow-y: auto;
    scroll-behavior: smooth;
    font-size: 14px;
    background: none;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    border-radius: 8px;
    z-index: 5;
}

#editorBG {
    position: fixed;
    top: 2.5px;
    padding: 20px;
    margin: 10px;
    width: calc(100% - 60px);
    height: calc(100vh - 150px);
    background-color: #fff;
    border-radius: 8px;
}

#editor::-webkit-scrollbar {
    display: none; /* Hide scrollbars in WebKit browsers */
}

.toolbar .save {
    position: absolute;
    background-color: #4CAF50;
    transition: background-color 0.3s ease, transform 0.3s ease;
    right: 94%;
}

.toolbar .open {
    position: absolute;
    background-color: #03A9F4;
    transition: background-color 0.3s ease, transform 0.3s ease;
    left: 94%;
}

.toolbar .save:hover{
    transform: translateX(8px)

}
.toolbar .open:hover {
    transform: translateX(-8px);
}

.hide {
    display: none;
}

.modal-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    z-index: 95;
    animation: fadeIn 0.3s ease;
}

.modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    z-index: 99;
    min-width: 300px;
    animation: slideIn 0.3s ease;
}

.modal h2 {
    margin-top: 0;
    margin-bottom: 12px;
    color: #333;
}

.modal input {
    position: relative;
    width: 92%;
    padding: 10px;
    margin: 10px 0;
    border: 2px solid #6200ea;
    border-radius: 6px;
    outline: none;
    margin-bottom: 20px;
}

.modal button {
    padding: 10px 20px;
    margin: 5px;
    border: none;
    border-radius: 6px;
    background: #6200ea;
    color: white;
    cursor: pointer;
    transition: background 0.3s ease;
}

.modal button:hover {
    background: #3700b3;
}

.modal button.cancel {
    background: #dc3545;
}

.modal button.cancel:hover {
    background: #c82333;
}

.saved-files-list {
    max-height: 300px;
    overflow-y: auto;
    margin: 10px 0;
}

.saved-file-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px;
    margin: 5px 0;
    background: #f8f9fa;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.2s ease;
}

.saved-file-item:hover {
    background: #e9ecef;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes slideIn {
    from {
        transform: translate(-50%, -60%);
        opacity: 0;
    }
    to {
        transform: translate(-50%, -50%);
        opacity: 1;
    }
}

.save-options {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin: 15px 0;
}

.save-option {
    padding: 15px;
    border: 2px solid #6200ea;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
}

.save-option:hover {
    background: #f0e7fe;
}

.save-option.selected {
    background: #6200ea;
    color: white;
}

.unencrypted-badge {
    display: inline-block;
    padding: 3px 8px;
    background: #dc3545;
    color: white;
    border-radius: 4px;
    font-size: 12px;
    margin-left: 8px;
}

.encrypted-badge {
    display: inline-block;
    padding: 3px 8px;
    background: #28a745;
    color: white;
    border-radius: 4px;
    font-size: 12px;
    margin-left: 8px;
}

.resizable {
    position: relative;
    display: inline-block;
    transition: transform 0.3s ease;
    transform-origin: center center;
    max-width: fit-content;
    max-height: fit-content;
}

.resizable img {
    display: block;
    border-radius: 8px;
}

.resize-handle {
    position: absolute;
    width: 10px;
    height: 10px;
    background: #fff;
    border: 2px solid #6200ea;
    border-radius: 50%;
    transition: transform 0.3s ease;
}

.resize-handle:hover {
  transform: scale(1.4);
}

.resize-handle.top-left {
    top: -5px;
    left: -5px;
    cursor: nwse-resize;
}

.resize-handle.top-right {
    top: -5px;
    right: -5px;
    cursor: nesw-resize;
}

.resize-handle.bottom-left {
    bottom: -5px;
    left: -5px;
    cursor: nesw-resize;
}

.resize-handle.bottom-right {
    bottom: -5px;
    right: -5px;
    cursor: nwse-resize;
}

table, th, td {
    border: 1px solid #ccc;
    border-collapse: collapse;
    padding: 10px;
    background-color: #fff;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
    transition: box-shadow 0.3s ease;
    border-radius: 2px;
}

table:hover, th:hover, td:hover {
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
}

#drawingCanvas {
    z-index: 1;
    position: absolute;
    margin-left: 10px;
    margin-top: 12px;
    border-radius: 8px;
}
</style>
<body>
  <div id="editorBG" contenteditable="false"></div>
    <div id="editor" contenteditable="true" role="textbox" aria-label="Content editor"></div>
    <div class="toolbar" id="textToolbar" role="toolbar" aria-label="Text formatting tools">
        <button class="save" id="save" aria-label="Save the document with options">Save</button>
        <button onclick="execCmd('bold')" aria-label="Make text bold">Bold</button>
        <button onclick="execCmd('italic')" aria-label="Make text italic">Italic</button>
        <button onclick="execCmd('underline')" aria-label="Make text underlined">Underline</button>
        <select id="fontSelect" onchange="changeFont(this.value)" aria-label="Select font">
            <option value="Roboto">Roboto</option>
            <option value="Arial">Arial</option>
            <option value="Courier New">Courier New</option>
            <option value="Georgia">Georgia</option>
            <option value="Times New Roman">Times New Roman</option>
            <option value="Verdana">Verdana</option>
            <option value="Comic Sans MS">Comic Sans MS</option>
            <option value="Trebuchet MS">Trebuchet MS</option>
        </select>
        <button onclick="insertTable()" aria-label="Insert table">Insert Table</button>
        <button onclick="changeFontSize(-1)" aria-label="Decrease font size">A-</button>
        <button onclick="changeFontSize(1)" aria-label="Increase font size">A+</button>
        <button onclick="toggleDrawingToolbar()" aria-label="Toggle drawing tools">Draw</button>
        <select id="alignSelect" onchange="changeAlignment(this.value)" aria-label="Text alignment">
            <option value="">Align</option>
            <option value="justifyLeft">Left</option>
            <option value="justifyCenter">Center</option>
            <option value="justifyRight">Right</option>
        </select>
        <button class="open" id="open" aria-label="Open a document">Open</button>
    </div>
      
  <div class="toolbar hide" id="tableToolbar" role="toolbar" aria-label="Table editing tools">
    <button onclick="addRow()">Add Row</button>
    <button onclick="addColumn()">Add Column</button>
    <button onclick="deleteRow()">Delete Row</button>
    <button onclick="deleteColumn()">Delete Column</button>
    <button onclick="mergeCells()">Merge Cells</button>
    <button onclick="splitCell()">Split Cell</button>
    <select onchange="setCellType(this.value)">
      <option value="">Cell Type</option>
      <option value="th">Header</option>
      <option value="td">Cell</option>
    </select>
    <select onchange="setAlignment(this.value)">
      <option value="">Align</option>
      <option value="left">Left</option>
      <option value="center">Center</option>
      <option value="right">Right</option>
    </select>
    <button onclick="toggleTextToolbar()">Exit Table Mode</button>
  </div>
  
 <div class="toolbar hide" id="drawingToolbar" role="toolbar" aria-label="Drawing tools">
        <button onclick="selectPenColor()" aria-label="Select pen tool">Pen</button>
        <button onclick="selectHighlighter()" aria-label="Select highlighter tool">Highlighter</button>
        <button onclick="selectEraser()" aria-label="Select eraser tool">Eraser</button>
        <input type="color" id="penColor" value="#000000" aria-label="Select color">
        <button onclick="setInkThickness(1)" aria-label="Set thin line width">Thin</button>
        <button onclick="setInkThickness(5)" aria-label="Set medium line width">Medium</button>
        <button onclick="setInkThickness(10)" aria-label="Set thick line width">Thick</button>
        <button onclick="saveAndHideDrawingToolbar()" aria-label="Save drawing and exit">Done</button>
    </div>

  <div id="modalOverlay" class="modal-overlay" role="dialog" aria-modal="true">
    <div id="passwordModal" class="modal">
        <h2 id="passwordModalTitle">Enter Password</h2>
        <input type="password" id="passwordInput" placeholder="Enter password">
        <div style="text-align: center;">
            <button onclick="cancelPasswordModal()">Cancel</button>
            <button onclick="confirmPassword()">Confirm</button>
        </div>
    </div>
    
    <div id="openFileModal" class="modal" style="display: none;">
        <h2>Open File</h2>
        <div class="saved-files-list" id="savedFilesList"></div>
        <div style="text-align: center;">
            <button onclick="document.getElementById('fileInput').click()">Open File</button>
            <button onclick="hideModal()">Cancel</button>
        </div>
    </div>
</div>

<div id="saveOptionsModal" class="modal" style="display: none;">
  <h2>Save Options</h2>
  <div class="save-options">
      <div class="save-option" onclick="selectSaveOption('encrypted')">
          <strong>Save with Encryption</strong>
          <p style="margin: 5px 0">Secure your document with password protection</p>
      </div>
      <div class="save-option" onclick="selectSaveOption('unencrypted')">
          <strong>Save without Encryption</strong>
          <p style="margin: 5px 0">Save document without password protection</p>
      </div>
  </div>
  <div class="save-options">
      <div class="save-option" onclick="selectSaveOption('local')">
          <strong>Save to Browser Storage Only</strong>
          <p style="margin: 5px 0">Keep document in browser storage</p>
      </div>
      <div class="save-option" onclick="selectSaveOption('download')">
          <strong>Save as File</strong>
          <p style="margin: 5px 0">Download document to your computer</p>
      </div>
      <div class="save-option" onclick="selectSaveOption('both')">
          <strong>Save Both</strong>
          <p style="margin: 5px 0">Save to browser storage and download</p>
      </div>
  </div>
  <div style="text-align: right; margin-top: 15px;">
      <button onclick="hideModal()">Cancel</button>
      <button onclick="proceedWithSave()">Continue</button>
  </div>
</div>

<div id="prompt" class="modal" style="display: none;">
	<h2 id="title"></h2>
	<input type="text" id="p_text"></input>
</div>
  
  <canvas id="drawingCanvas" role="img" aria-label="Drawing canvas"></canvas>
  <input type="file" id="fileInput" accept=".ebf" style="display:none">
 <script>
 
    let fontSize = 14;
    let lastFont = "Roboto";
    let lastAlignment = 'justifyLeft';
    let selectedImage = null;
    let isDrawing = false;
    let savedDrawingData

    function execCmd(command) {
  if (command === 'indent') {
    document.execCommand('indent', false, null);
    const selection = window.getSelection();
    const range = selection.getRangeAt(0);
    const parentElement = range.startContainer.parentElement;
    if (parentElement.tagName !== 'LI') {
      document.execCommand('insertUnorderedList', false, null);
    }
  } else {
    document.execCommand(command, false, null);
  }
}

// Prompts
function prompts(text, placeholder) {
  return new Promise((resolve, reject) => {
    const modal = document.getElementById('prompt');
    const title = document.getElementById('title');
    const input = document.getElementById('p_text');
    
    if (!modal || !title || !input) {
      reject(new Error('Required DOM elements not found'));
      return;
    }

    // Clear previous value
    input.value = '';
    
    modal.style.display = "block";
    title.textContent = text;
    input.placeholder = placeholder;

    input.onkeyup = (e) => {
      if (e.key === 'Enter') {
        const value = input.value;
        modal.style.display = "none";
        input.onkeyup = null;
        resolve(value);
      }
    };
    
  });
}
// link handling

document.getElementById('editor').addEventListener('click', function(event) {
  const range = document.caretRangeFromPoint(event.clientX, event.clientY);
  if (!range) return;

  const node = range.startContainer;
  const element = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
  const link = element.closest('a');

  if (link) {
    event.preventDefault();
    window.open(link.href, '_blank');
    window.focus();
    return;
  }

  if (event.ctrlKey) {
    const text = getSelectedText(range);
    if (isValidURL(text)) {
      event.preventDefault();
      const url = text.startsWith('http') ? text : 'https://' + text;
      const a = document.createElement('a');
      a.href = url;
      a.textContent = text;
      a.style.color = '#0066cc';
      a.style.textDecoration = 'underline';
      replaceSelectedText(range, a);
      window.open(url, '_blank').focus();
    }
  }
});

// Add styles for links in the editor
const style = document.createElement('style');
style.textContent = `
  #editor a:not([style*="color"]) {
    color: #0066cc;
    text-decoration: underline;
  }
`;
document.head.appendChild(style);

function getSelectedText(range) {
  const preSelectionRange = range.cloneRange();
  preSelectionRange.selectNodeContents(document.getElementById('editor'));
  preSelectionRange.setEnd(range.startContainer, range.startOffset);
  
  const start = preSelectionRange.toString().length;
  const text = document.getElementById('editor').textContent;
  let word = '';
  
  for (let i = start - 1; i >= 0; i--) {
    if (/\s/.test(text[i])) break;
    word = text[i] + word;
  }
  
  for (let i = start; i < text.length; i++) {
    if (/\s/.test(text[i])) break;
    word += text[i];
  }
  
  return word.trim();
}

function isValidURL(text) {
  const pattern = /^(https?:\/\/)?([\w.-]+\.[a-zA-Z]{2,})(\/\S*)?$/;
  return pattern.test(text);
}

function replaceSelectedText(range, newContent) {
  const span = document.createElement('span');
  span.appendChild(newContent);
  
  const selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range);
  
  document.execCommand('insertHTML', false, span.innerHTML);
}

// drawingCanvas automatic resize
const resizeHandler = () => {
    const canvas = document.getElementById('drawingCanvas');
    canvas.width = window.innerWidth - 20;
    canvas.height = window.innerHeight - 108;
};

window.addEventListener('resize', resizeHandler);
resizeHandler();


// Zoom
document.addEventListener('DOMContentLoaded', function() {
    let currentScale = 1;
    let initialDistance = 0;

    function initializePinchToZoom(editor) {
        function handleTouchStart(event) {
            if (event.touches.length === 2) {
                initialDistance = getDistance(event.touches[0], event.touches[1]);
            }
        }

        function handleTouchMove(event) {
            if (event.touches.length === 2) {
                event.preventDefault();
                const newDistance = getDistance(event.touches[0], event.touches[1]);
                const scaleChange = newDistance / initialDistance;
                currentScale *= scaleChange;
                editor.style.transform = `scale(${currentScale})`;
                initialDistance = newDistance;
            }
        }
        
        function updateScale(currentScale) {
    		const newScale = currentScale * 2; // Replace eval with direct calculation
    		return `scale(${newScale})`;
		}

        function handleTouchEnd(event) {
            // Ensure the scale stays within reasonable bounds
            if (currentScale < 0.2) {
                currentScale = 0.2;
            } else if (currentScale > 3) {
                currentScale = 3;
            }
            editor.style.transform = `scale(${currentScale})`;
            resizeScale.style.transform = eval(currentScale + currentScale);
        }

        function getDistance(touch1, touch2) {
            return Math.hypot(touch2.pageX - touch1.pageX, touch2.pageY - touch1.pageY);
        }

        editor.addEventListener('touchstart', handleTouchStart);
        editor.addEventListener('touchmove', handleTouchMove);
        editor.addEventListener('touchend', handleTouchEnd);
        
        // Mouse wheel zoom
        editor.addEventListener('wheel', handleWheelZoom);
    }

    function handleWheelZoom(event) {
        event.preventDefault();
        const zoomFactor = 0.1;
        const delta = Math.sign(event.deltaY);
        currentScale += delta * -zoomFactor;
        // Ensure the scale stays within reasonable bounds
        if (currentScale < 0.2) {
            currentScale = 0.2;
        } else if (currentScale > 3) {
            currentScale = 3;
        }
        const editor = event.currentTarget;
        editor.style.transform = `scale(${currentScale})`;
    }

    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.addedNodes.length) {
                mutation.addedNodes.forEach((node) => {
                    if (node.classList && node.classList.contains('resizable')) {
                        initializePinchToZoom(node);
                    }
                });
            }
        });
    });

    observer.observe(document.body, { childList: true, subtree: true });

    // Check if any resizable elements are already present when the script runs
    document.querySelectorAll('.resizable').forEach((element) => {
        initializePinchToZoom(element);
    });
});

async function insertTable() {
    try {
        const rows = await prompts("Enter the number of rows", "2");
        const cols = await prompts("Enter the number of columns", "3");
        
        if (!rows || !cols || isNaN(rows) || isNaN(cols) || rows < 1 || cols < 1) {
            throw new Error("Invalid table dimensions");
        }

        let tableHtml = '<table role="grid">';
        for (let i = 0; i < rows; i++) {
            tableHtml += '<tr role="row">';
            for (let j = 0; j < cols; j++) {
                tableHtml += `<td role="gridcell" tabindex="0"><br></td>`;
            }
            tableHtml += '</tr>';
        }
        tableHtml += '</table>';

        const editor = document.getElementById('editor');
        editor.focus();
        document.execCommand('insertHTML', false, tableHtml);
        showToolbar('tableToolbar');
    } catch (err) {
        alert('Failed to create table: ' + err.message);
    }
}


document.addEventListener('keydown', function(event) {
  if (event.ctrlKey) {
    switch (event.key) {
      case 'b':
        event.preventDefault();
        execCmd('bold');
        break;
      case 'i':
        event.preventDefault();
        execCmd('italic');
        break;
      case 'u':
        event.preventDefault();
        execCmd('underline');
        break;
      case 'L' :
      	event.preventDefault();
      	changeAlignment('justifyLeft');
      	break;
      case 'C' :
      	event.preventDefault();
      	changeAlignment('justifyCenter');
      	break;
      case 'R' :
      	event.preventDefault();
      	changeAlignment('justifyRight');
      	break;
    }
  }
  if (event.key === 'Tab') 
	{ 
	event.preventDefault();
	execCmd('indent');
	} 

});

document.addEventListener('click', function(event) {
  if (event.target.tagName === 'TD' || event.target.tagName === 'TH') {
    selectedCell = event.target;
    showToolbar('tableToolbar');
  }
});

	// Text Editing
    function changeFont(font) {
      document.execCommand('fontName', false, font);
      lastFont = font;
    }

    function changeFontSize(change) {
      fontSize += change;
      document.execCommand('fontSize', false, fontSize);
    }

    function changeAlignment(alignment) {
      document.execCommand(alignment, false, null);
      lastAlignment = alignment;
      document.getElementById('alignSelect').value = "";
    }

document.getElementById('editor').addEventListener('click', function(event) {
  const textToolbar = document.getElementById('textToolbar');
  const imageToolbar = document.getElementById('imageToolbar');
  const drawingToolbar = document.getElementById('drawingToolbar');
  const drawingCanvas = document.getElementById('drawingCanvas');

  if (event.target.tagName === 'IMG') {
    selectedImage = event.target;
    wrapImage(selectedImage);
    textToolbar.classList.add('hide');
    if (imageToolbar) imageToolbar.classList.remove('hide'); // Check existence
    drawingToolbar.classList.add('hide');
    drawingCanvas.classList.add('hide');
  } else {
    textToolbar.classList.remove('hide');
    if (imageToolbar) imageToolbar.classList.add('hide'); // Check existence
    drawingToolbar.classList.add('hide');
    drawingCanvas.classList.add('hide');
    if (selectedImage) unwrapImage(selectedImage);
    selectedImage = null;
  }
});
let strokes = []; // Array to store all strokes
let currentStroke = []; // Array to store the current stroke

function toggleDrawingToolbar() {
    const drawingToolbar = document.getElementById('drawingToolbar');
    const drawingCanvas = document.getElementById('drawingCanvas');
    const textToolbar = document.getElementById('textToolbar');
    const imageToolbar = document.getElementById('imageToolbar');

    drawingToolbar.classList.toggle('hide');
    textToolbar.classList.toggle('hide', !drawingToolbar.classList.contains('hide'));
    if (imageToolbar) imageToolbar.classList.add('hide'); // Check existence

    if (!drawingToolbar.classList.contains('hide')) {
        drawingCanvas.style.display = 'block';
        drawingCanvas.style.zIndex = '6';
        context = drawingCanvas.getContext('2d'); // Initialize context

        // Render saved drawing if it exists
        if (savedDrawingData) {
            const savedImage = new Image();
            savedImage.src = savedDrawingData;
            savedImage.onload = () => context.drawImage(savedImage, 0, 0);
        }
    } else {
        drawingCanvas.style.display = 'none';
    }
}

function saveAndHideDrawingToolbar() {
    const drawingCanvas = document.getElementById('drawingCanvas');
    const drawingToolbar = document.getElementById('drawingToolbar');
    const textToolbar = document.getElementById('textToolbar');

    if (drawingCanvas) {
        savedDrawingData = drawingCanvas.toDataURL();
    }

    // Keep canvas behind the text
    drawingCanvas.style.zIndex = '0';
    textToolbar.classList.remove('hide');
    drawingToolbar.classList.add('hide');
}

function setInkThickness(thickness) {
    context.lineWidth = thickness;
}

function selectPenColor() {
    context.lineWidth = 5;
    context.globalCompositeOperation = 'source-over'; // Ensure we're in drawing mode
    context.strokeStyle = document.getElementById('penColor').value;
}

function selectHighlighter(color) {
    context.lineWidth = 10;
    context.strokeStyle = document.getElementById('penColor').value;
}

function selectEraser() {
    context.globalCompositeOperation = 'destination-out';
    context.lineWidth = 30; // Set eraser thickness here

    // Function to erase strokes
    drawingCanvas.addEventListener('mousedown', function(event) {
        const pos = getMousePos(event);
        strokes = strokes.filter(stroke => {
            const isErased = stroke.some(point => {
                return Math.abs(point.x - pos.x) < context.lineWidth && Math.abs(point.y - pos.y) < context.lineWidth;
            });
            return !isErased; // Remove stroke if any point is within the eraser range
        });
    });
}

document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('drawingCanvas');
    context = canvas.getContext('2d');
});

document.getElementById('drawingCanvas').addEventListener('mousedown', startDrawing);
document.getElementById('drawingCanvas').addEventListener('touchstart', startDrawing);

document.getElementById('drawingCanvas').addEventListener('mousemove', draw);
document.getElementById('drawingCanvas').addEventListener('touchmove', draw);

document.getElementById('drawingCanvas').addEventListener('mouseup', stopDrawing);
document.getElementById('drawingCanvas').addEventListener('touchend', stopDrawing);

document.getElementById('drawingCanvas').addEventListener('mouseout', stopDrawing);
document.getElementById('drawingCanvas').addEventListener('touchcancel', stopDrawing);

function getMousePos(event) {
    const rect = drawingCanvas.getBoundingClientRect();
    return {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}

function drawLine(context, x1, y1, x2, y2) {
    context.beginPath();
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    context.stroke();
    context.closePath();
}

function startDrawing(event) {
    isDrawing = true;
    const pos = getMousePos(event);
    x = pos.x;
    y = pos.y;
    currentStroke = [{x, y}]; // Start a new stroke
}

function draw(event) {
    event.preventDefault();
    if (isDrawing === true) {
        const pos = getMousePos(event);
        drawLine(context, x, y, pos.x, pos.y);
        x = pos.x;
        y = pos.y;
        currentStroke.push({x, y}); // Add point to the current stroke
    }
}

function stopDrawing() {
    if (isDrawing === true) {
        isDrawing = false;
        strokes.push(currentStroke); // Add the current stroke to the array of strokes
        context.globalCompositeOperation = 'source-over'; // Reset composite operation after erasing
    }
}

let selectedCell = null;

document.addEventListener('click', function(event) {
  if (event.target.tagName === 'TD' || event.target.tagName === 'TH') {
    selectedCell = event.target;
    showTableToolbar();
  } else if (!event.target.closest('.toolbar')) {
    showToolbar('textToolbar');
  }
});


  function showTableToolbar() {
  const tableToolbar = document.getElementById('tableToolbar');
  const textToolbar = document.getElementById('textToolbar');
  const drawingToolbar = document.getElementById('drawingToolbar');
  const imageToolbar = document.getElementById('imageToolbar');
  const drawingCanvas = document.getElementById('drawingCanvas');

  tableToolbar.classList.remove('hide');
  textToolbar.classList.add('hide');
  if (drawingToolbar) drawingToolbar.classList.add('hide');
  if (imageToolbar) imageToolbar.classList.add('hide');
  if (drawingCanvas) drawingCanvas.style.display = 'none'; // Hide the drawing canvas if it's visible
}



function addRow() {
  if (selectedCell) {
    const row = selectedCell.parentElement.cloneNode(true);
    selectedCell.parentElement.parentElement.appendChild(row);
  }
}

function addColumn() {
  if (selectedCell) {
    const rows = selectedCell.parentElement.parentElement.rows;
    for (let i = 0; i < rows.length; i++) {
      rows[i].insertCell(selectedCell.cellIndex + 1).innerHTML = "";
    }
  }
}

function deleteRow() {
  if (selectedCell) {
    selectedCell.parentElement.remove();
  }
}

function deleteColumn() {
  if (selectedCell) {
    const rows = selectedCell.parentElement.parentElement.rows;
    for (let i = 0; i < rows.length; i++) {
      rows[i].deleteCell(selectedCell.cellIndex);
    }
  }
}

async function mergeCells() {
  if (selectedCell) {
    const span = parseInt(await prompts("Enter colspan or rowspan value:", "2"));
    if (span) {
      selectedCell.colSpan = span;
    }
  }
}

function splitCell() {
  if (selectedCell && selectedCell.colSpan > 1) {
    selectedCell.colSpan = 1;
  }
}

function setCellType(type) {
  if (selectedCell) {
    const cellType = document.createElement(type);
    cellType.innerHTML = selectedCell.innerHTML;
    selectedCell.parentElement.replaceChild(cellType, selectedCell);
    selectedCell = cellType;
  }
}

function setAlignment(alignment) {
  if (selectedCell) {
    selectedCell.style.textAlign = alignment;
  }
}

function toggleTableToolbar() {
  const tableToolbar = document.getElementById('tableToolbar');
  const textToolbar = document.getElementById('textToolbar');
  if (tableToolbar.classList.contains('hide')) {
    tableToolbar.classList.remove('hide');
    textToolbar.classList.add('hide');
  } else {
    tableToolbar.classList.add('hide');
    textToolbar.classList.remove('hide');
  }
}

function showToolbar(toolbarId) {
  const toolbars = document.querySelectorAll('.toolbar');
  toolbars.forEach(toolbar => {
    if (toolbar.id === toolbarId) {
      toolbar.classList.remove('hide');
    } else {
      toolbar.classList.add('hide');
    }
  });
}

function toggleTextToolbar() {
  showToolbar('textToolbar');

  // Insert a <br> after the table and move the cursor
  const editor = document.getElementById('editor');
  const selection = window.getSelection();
  const range = document.createRange();
  const br = document.createElement('br');
  editor.appendChild(br);
  range.setStartAfter(editor.lastChild);
  range.setEndAfter(editor.lastChild);
  selection.removeAllRanges();
  selection.addRange(range);
}

   function getMousePos(event) {
      const rect = drawingCanvas.getBoundingClientRect();
      const clientX = event.clientX || event.touches[0].clientX;
      const clientY = event.clientY || event.touches[0].clientY;
      return {
        x: clientX - rect.left,
        y: clientY - rect.top
      };
    }
    
    function drawLine(context, x1, y1, x2, y2) {
      context.beginPath();
      context.lineWidth = context.lineWidth; // Maintain current line width
      context.moveTo(x1, y1);
      context.lineTo(x2, y2);
      context.stroke();
      context.closePath();
    }

    // Function to remove resize handles
    function removeResizeHandles() {
      const handles = document.querySelectorAll('.resize-handle');
      handles.forEach(handle => handle.remove());
    }

    // Ensure resize handles are removed when image is deselected
    document.getElementById('editor').addEventListener('click', function(event) {
      const textToolbar = document.getElementById('textToolbar');
      const imageToolbar = document.getElementById('imageToolbar');
      const drawingToolbar = document.getElementById('drawingToolbar');
      const drawingCanvas = document.getElementById('drawingCanvas');

      if (event.target.tagName !== 'IMG') {
          removeResizeHandles();
      }
    });

function loadImage(src) {
  const img = new Image();
  img.src = src;
  img.onload = () => document.getElementById('editor').appendChild(img);
}

   function wrapImage(image) {
  if (!image.parentElement.classList.contains('resizable')) {
    const wrapper = document.createElement('div');
    wrapper.classList.add('resizable');
    image.parentNode.insertBefore(wrapper, image);
    wrapper.appendChild(image);
    addResizeHandles(wrapper);
  }
}

async function convertImageToBase64(url) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                resolve(canvas.toDataURL('image/png'));
            } catch (err) {
                reject(new Error('Failed to convert image: ' + err.message));
            }
        };
        img.onerror = () => reject(new Error('Failed to load image'));
        img.src = url;
    });
}

function unwrapImage(image) {
  const wrapper = image.parentElement;
  if (wrapper.classList.contains('resizable')) {
    wrapper.replaceWith(image);
  }
}

function addResizeHandles(wrapper) {
  const handles = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
  handles.forEach(handle => {
    const handleDiv = document.createElement('div');
    handleDiv.classList.add('resize-handle', handle);
    handleDiv.addEventListener('mousedown', initResize);
    wrapper.appendChild(handleDiv);
  });
}

function initResize(event) {
  startX = event.clientX;
  startY = event.clientY;
  startWidth = parseInt(document.defaultView.getComputedStyle(selectedImage).width, 10);
  startHeight = parseInt(document.defaultView.getComputedStyle(selectedImage).height, 10);
  document.documentElement.addEventListener('mousemove', doResize);
  document.documentElement.addEventListener('mouseup', stopResize);
}

function doResize(event) {
  selectedImage.width = startWidth + event.clientX - startX;
  selectedImage.height = startHeight + event.clientY - startY;
}

function stopResize() {
  document.documentElement.removeEventListener('mousemove', doResize);
  document.documentElement.removeEventListener('mouseup', stopResize);
}

const FILE_MARKERS = {
    UNENCRYPTED_V2: "EBF_UNENCRYPTED_V2",
    ENCRYPTED_V2: "EBF_ENCRYPTED_V2"
};

// Event handlers for the UI integration
document.addEventListener('DOMContentLoaded', () => {
    // Save button handler
    document.getElementById('save').onclick = (e) => {
        e.preventDefault();
        showSaveOptions();
    };

    // Open button handler
    document.getElementById('open').onclick = (e) => {
        e.preventDefault();
        showOpenFileModal();
    };

    // File input change handler
    document.getElementById('fileInput').onchange = async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const fileData = JSON.parse(e.target.result);
                
                if (fileData.marker === FILE_MARKERS.ENCRYPTED_V2) {
                    showPasswordModal("Enter Password to Decrypt", async (password) => {
                        try {
                            await openFile({
                                fileContent: e.target.result,
                                password,
                                editorElement: document.getElementById('editor'),
                                canvasElement: document.getElementById('drawingCanvas')
                            });
                            hideModal();
                        } catch (error) {
                            alert("Invalid password!");
                            showPasswordModal("Enter Password to Decrypt", arguments.callee);
                        }
                    });
                } else {
                    await openFile({
                        fileContent: e.target.result,
                        editorElement: document.getElementById('editor'),
                        canvasElement: document.getElementById('drawingCanvas')
                    });
                }
            } catch (error) {
                alert('Failed to open file: ' + error.message);
           }
        };
        reader.readAsText(file);
    };

    // Modal handlers
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            hideModal();
        }
    });
});

// Save option selection state
let selectedSaveOptions = {
    encryption: null,
    saveLocation: null
};

// Modal management
function showSaveOptions() {
    selectedSaveOptions = { encryption: null, saveLocation: null };
    document.querySelectorAll('.save-option').forEach(opt => {
        opt.classList.remove('selected');
    });
    
    document.getElementById('modalOverlay').style.display = 'block';
    document.getElementById('saveOptionsModal').style.display = 'block';
    document.getElementById('passwordModal').style.display = 'none';
    document.getElementById('openFileModal').style.display = 'none';
}

function selectSaveOption(option) {
    if (['encrypted', 'unencrypted'].includes(option)) {
        selectedSaveOptions.encryption = option;
        document.querySelectorAll('.save-options:first-of-type .save-option')
            .forEach(opt => opt.classList.remove('selected'));
    } else {
        selectedSaveOptions.saveLocation = option;
        document.querySelectorAll('.save-options:last-of-type .save-option')
            .forEach(opt => opt.classList.remove('selected'));
    }
    event.currentTarget.classList.add('selected');
}

async function proceedWithSave() {
    if (!selectedSaveOptions.encryption || !selectedSaveOptions.saveLocation) {
        alert("Please select both encryption and save location options");
        return;
    }

    const fileName = await prompts("Enter filename:", "doc");
    if (!fileName) return;

    try {
        if (selectedSaveOptions.encryption === 'encrypted') {
            showPasswordModal("Set Password for Encryption", async (password) => {
                try {
                    await saveFile({
                        fileName,
                        password,
                        saveLocation: selectedSaveOptions.saveLocation,
                        editorElement: document.getElementById('editor'),
                        drawingData: savedDrawingData
                    });
                    hideModal();
                } catch (error) {
                    alert('Failed to save file: ' + error.message);
                }
            });
        } else {
            await saveFile({
                fileName,
                saveLocation: selectedSaveOptions.saveLocation,
                editorElement: document.getElementById('editor'),
                drawingData: savedDrawingData
            });
            hideModal();
        }
    } catch (error) {
        alert('Failed to save file: ' + error.message);
    }
}

function showOpenFileModal() {
    const savedFiles = JSON.parse(localStorage.getItem('ebfFiles') || '{}');
    const filesList = document.getElementById('savedFilesList');
    filesList.innerHTML = '';
    
    Object.entries(savedFiles).forEach(([name, file]) => {
        const fileItem = document.createElement('div');
        fileItem.className = 'saved-file-item';
        fileItem.innerHTML = `
            <span>${name}
                ${file.encrypted ? 
                    '<span class="encrypted-badge">Encrypted</span>' : 
                    '<span class="unencrypted-badge">Unencrypted</span>'}
            </span>
            <span>${new Date(file.date).toLocaleDateString()}</span>
        `;
        fileItem.onclick = () => openSavedFile(name);
        filesList.appendChild(fileItem);
    });
    
    document.getElementById('modalOverlay').style.display = 'block';
    document.getElementById('openFileModal').style.display = 'block';
    document.getElementById('passwordModal').style.display = 'none';
    document.getElementById('saveOptionsModal').style.display = 'none';
}

async function openSavedFile(fileName) {
    const savedFiles = JSON.parse(localStorage.getItem('ebfFiles') || '{}');
    const fileData = savedFiles[fileName];
    if (!fileData) return;

    if (fileData.encrypted) {
        document.getElementById('openFileModal').style.display = 'none';
        showPasswordModal("Enter Password to Decrypt", async (password) => {
            try {
                await openFile({
                    fileName,
                    password,
                    editorElement: document.getElementById('editor'),
                    canvasElement: document.getElementById('drawingCanvas')
                });
                hideModal();
            } catch (error) {
                alert("Invalid password!");
                showPasswordModal("Enter Password to Decrypt", arguments.callee);
            }
        });
    } else {
        await openFile({
            fileName,
            editorElement: document.getElementById('editor'),
            canvasElement: document.getElementById('drawingCanvas')
        });
        hideModal();
    }
}

// Password modal management
let currentModalCallback = null;

function showPasswordModal(title, callback) {
    document.getElementById('modalOverlay').style.display = 'block';
    document.getElementById('passwordModal').style.display = 'block';
    document.getElementById('saveOptionsModal').style.display = 'none';
    document.getElementById('openFileModal').style.display = 'none';
    document.getElementById('passwordModalTitle').textContent = title;
    document.getElementById('passwordInput').value = '';
    currentModalCallback = callback;
}

function hideModal() {
    document.getElementById('modalOverlay').style.display = 'none';
    document.getElementById('passwordModal').style.display = 'none';
    document.getElementById('openFileModal').style.display = 'none';
    document.getElementById('saveOptionsModal').style.display = 'none';
    
    selectedSaveOptions = { encryption: null, saveLocation: null };
    document.querySelectorAll('.save-option').forEach(opt => {
        opt.classList.remove('selected');
    });
    
    currentModalCallback = null;
}

function cancelPasswordModal() {
    hideModal();
}

async function confirmPassword() {
    const password = document.getElementById('passwordInput').value;
    if (password && currentModalCallback) {
        await currentModalCallback(password);
    }
}

async function saveFile({
    fileName,
    password = null,
    saveLocation,
    editorElement,
    drawingData = null
}) {
    try {
        // Gather content
        const editorContent = editorElement.innerHTML;
        const inkData = drawingData ? `<ink:${drawingData}>` : '';
        
        // Handle images more efficiently
        const imageData = await Promise.all(
            Array.from(editorElement.querySelectorAll('img'))
                .map(async (img) => {
                    const base64 = img.src.startsWith('data:image') 
                        ? img.src 
                        : await new Promise(resolve => convertImageToBase64(img.src, resolve));
                    return `<picture:${base64}>`;
                })
        ).then(images => images.join(''));

        const content = `${editorContent}${inkData}${imageData}`;
        
        // Prepare file data
        let fileData;
        
        if (password) {
            const encryptedData = await encryptContent(content, password);
            fileData = {
                marker: FILE_MARKERS.ENCRYPTED_V2,
                name: fileName,
                data: {
                    encrypted: Array.from(encryptedData.encrypted),
                    salt: Array.from(encryptedData.salt),
                    iv: Array.from(encryptedData.iv)
                },
                date: new Date().toISOString(),
                encrypted: true
            };
        } else {
            fileData = {
                marker: FILE_MARKERS.UNENCRYPTED_V2,
                name: fileName,
                data: content,
                date: new Date().toISOString(),
                encrypted: false
            };
        }


        if (['local', 'both'].includes(saveLocation)) {
            const savedFiles = JSON.parse(localStorage.getItem('ebfFiles') || '{}');
            savedFiles[fileName] = fileData;
            localStorage.setItem('ebfFiles', JSON.stringify(savedFiles));
        }

        if (['download', 'both'].includes(saveLocation)) {
            const blob = new Blob([JSON.stringify(fileData)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${fileName}.ebf`;
            a.click();
            URL.revokeObjectURL(url);
        }

        return { success: true };
    } catch (error) {
        console.error('Save failed:', error);
        throw new Error('Failed to save the file');
    }
}

async function openFile({
    fileName = null,
    password = null,
    fileContent = null,
    editorElement,
    canvasElement = null
}) {
    try {
    	let fileData, content;
        
        if (fileName) {
            const savedFiles = JSON.parse(localStorage.getItem('ebfFiles') || '{}');
            fileData = savedFiles[fileName];
            if (!fileData) throw new Error('File not found');
        } else if (fileContent) {
            try {
                fileData = JSON.parse(fileContent);
            } catch {
                // If JSON parsing fails, treat as legacy HTML content
                content = fileContent;
                fileData = { data: content };
            }
        } else {
            throw new Error('Either fileName or fileContent must be provided');
        }

        if (!content) {
            if (fileData.marker === FILE_MARKERS.ENCRYPTED_V2) {
                if (!password) throw new Error('Password required');
                content = await decryptContent(fileData.data, password);
            } else if (fileData.marker === FILE_MARKERS.UNENCRYPTED_V2) {
                content = fileData.data;
            } else {
                content = fileData.data;
            }
        }
        

        const pictureRegex = /<picture:([^>]*)>/g;
        let match;
        const images = [];
        while ((match = pictureRegex.exec(content)) !== null) {
            images.push(match[1]);
        }
        
        if (canvasElement) {
            const inkDataMatch = content.match(/<ink:([^>]*)>/);
            if (inkDataMatch) {
                const drawingData = inkDataMatch[1];
                const context = canvasElement.getContext('2d');
                const savedImage = new Image();
                savedImage.src = drawingData;
                await new Promise(resolve => {
                    savedImage.onload = () => {
                        canvasElement.style.display = 'block';
                        canvasElement.style.zIndex = '0';
                        context.drawImage(savedImage, 0, 0);
                        resolve();
                    };
                });
            }
        }

        // Set editor content
        const cleanContent = content
            .replace(/<ink:.*>/, '')
            .replace(/<picture:[^>]*>/g, '');
        editorElement.innerHTML = cleanContent;

        return {
            success: true,
            images,
            isEncrypted: fileData.encrypted,
            name: fileData.name
        };
    } catch (error) {
        console.error('Open failed:', error);
        throw new Error(error.message || 'Failed to open the file');
    }
}

// Helper functions for encryption/decryption
async function encryptContent(content, password) {
    const encoder = new TextEncoder();
    const data = encoder.encode(content);
    const passwordKey = await crypto.subtle.importKey(
        'raw',
        encoder.encode(password),
        { name: 'PBKDF2' },
        false,
        ['deriveBits', 'deriveKey']
    );

    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));

    const key = await crypto.subtle.deriveKey(
        {
            name: 'PBKDF2',
            salt: salt,
            iterations: 100000,
            hash: 'SHA-256'
        },
        passwordKey,
        { name: 'AES-GCM', length: 256 },
        false,
        ['encrypt']
    );

    const encrypted = await crypto.subtle.encrypt(
        { name: 'AES-GCM', iv: iv },
        key,
        data
    );

    return {
        encrypted: new Uint8Array(encrypted),
        salt: salt,
        iv: iv
    };
}

async function decryptContent(encryptedData, password) {
    const encoder = new TextEncoder();
    const passwordKey = await crypto.subtle.importKey(
        'raw',
        encoder.encode(password),
        { name: 'PBKDF2' },
        false,
        ['deriveBits', 'deriveKey']
    );
    
    const key = await crypto.subtle.deriveKey(
        {
            name: 'PBKDF2',
            salt: new Uint8Array(encryptedData.salt),
            iterations: 100000,
            hash: 'SHA-256'
        },
        passwordKey,
        { name: 'AES-GCM', length: 256 },
        false,
        ['decrypt']
    );
    
    try {
        const decrypted = await crypto.subtle.decrypt(
            { name: 'AES-GCM', iv: new Uint8Array(encryptedData.iv) },
            key,
            new Uint8Array(encryptedData.encrypted)
        );
        
        return new TextDecoder().decode(decrypted);
    } catch (error) {
        throw new Error('Invalid password');
    }
}

</script>
</body>
</html>